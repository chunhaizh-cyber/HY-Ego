export  module 模板模块;

import 基础数据类型模块;

import <string>;
import <vector>;
import <functional>;
import <mutex>;
import <memory>;
import <type_traits>;

// 双向链表模板（环形）
// - 同层：用 上/下 构成环
// - 全链：用 链上/链下 把整棵树的所有节点串成一个环，便于全局扫描/序列化
// - 线程安全：默认对外接口会加锁（链表锁）。
//   为避免递归删除/批量操作时重复加锁，提供 *_已加锁 版本：调用者需已持有链表锁。

export template<typename 主信息类型>
class 链表模板 {
public:
    struct 节点类 {
        std::string  主键;

        节点类* 上 = nullptr;
        节点类* 下 = nullptr;

        节点类* 父 = nullptr;
        节点类* 子 = nullptr;

        节点类* 根 = nullptr;

        // 全链环（把整棵树所有节点串起来）
        节点类* 链上 = nullptr;
        节点类* 链下 = nullptr;

        主信息类型 主信息{};

        std::int64_t 子节点数量 = 0;

        void 变更子节点数量(std::int64_t delta) { 子节点数量 += delta; }
    };

    using 锁守卫 = std::unique_lock<std::recursive_mutex>;

    mutable std::recursive_mutex 链表锁;

    节点类* 根指针 = nullptr;

public:
    链表模板()
    {
        根指针 = new 节点类{};
        根指针->上 = 根指针;
        根指针->下 = 根指针;
        根指针->父 = nullptr;
        根指针->子 = nullptr;
        根指针->根 = 根指针;
        根指针->链上 = 根指针;
        根指针->链下 = 根指针;
        根指针->主键 = "root";
    }

    ~链表模板() { 删除链表(); }

    // 获取锁（可用于批量/递归操作时，由外部一次性加锁）
    锁守卫 获取锁() const { return 锁守卫(链表锁); }

private:
    // ====================== 主键生成 ======================
    std::string 获取新主键(const std::string& 前一主键) const
    {
        constexpr char 字符集[] =
            "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
        constexpr std::size_t 字符集大小 = sizeof(字符集) - 1;

        std::string 新主键 = 前一主键;

        // 从末位开始进位
        for (int i = static_cast<int>(新主键.size()) - 1; i >= 0; --i) {
            std::size_t pos = 0;
            while (pos < 字符集大小 && 字符集[pos] != 新主键[i]) ++pos;

            if (pos + 1 < 字符集大小) {
                新主键[i] = 字符集[pos + 1];
                return 新主键;
            }
            新主键[i] = 字符集[0];
        }

        // 全部溢出：前面补 1
        新主键.insert(新主键.begin(), 字符集[1]);
        return 新主键;
    }

    // 把“新节点”追加到“全链环”尾部（在 根链 的链上/链下 上维护）
    void 更新链指针_已加锁(节点类* 根链, 节点类* 新节点)
    {
        if (!根链 || !新节点) return;

        // 插到 根链->链上 (尾) 与 根链 (头) 之间
        新节点->链上 = 根链->链上;
        新节点->链下 = 根链;

        根链->链上->链下 = 新节点;
        根链->链上 = 新节点;
    }

public:
    // =============================================================
    // 1) 添加节点：同层环插入 + 全链环登记
    // =============================================================

    // *_已加锁：调用者需已持有 链表锁
    节点类* 添加节点_已加锁(节点类* 位置节点, 节点类* 新节点)
    {
        if (!新节点) return nullptr;

        if (!位置节点) {
            位置节点 = 根指针;
        }

        // 继承父/根
        新节点->根 = 位置节点->根;
        新节点->父 = 位置节点->父;

        // 插入同层环：插到 位置节点 与 位置节点->下 之间
        新节点->上 = 位置节点;
        新节点->下 = 位置节点->下;

        位置节点->下->上 = 新节点;
        位置节点->下 = 新节点;

        // 主键递增（使用根链的主键种子）
        根指针->主键 = 新节点->主键 = 获取新主键(根指针->主键);

        // 维护父节点数量
        if (新节点->父) {
            新节点->父->变更子节点数量(1);
        }

        更新链指针_已加锁(根指针, 新节点);
        return 新节点;
    }

    节点类* 添加节点(节点类* 位置节点, 节点类* 新节点)
    {
        std::lock_guard<std::recursive_mutex> lock(链表锁);
        return 添加节点_已加锁(位置节点, 新节点);
    }

    节点类* 添加节点_已加锁(节点类* 位置节点, 主信息类型 主信息)
    {
        auto* 新节点 = new 节点类{};
        新节点->主信息 = 主信息;
        return 添加节点_已加锁(位置节点, 新节点);
    }

    节点类* 添加节点(节点类* 位置节点, 主信息类型 主信息)
    {
        std::lock_guard<std::recursive_mutex> lock(链表锁);
        return 添加节点_已加锁(位置节点, 主信息);
    }

    // =============================================================
    // 2) 添加子节点：挂到 父节点 的 子链（同层环）+ 全链环登记
    // =============================================================

    节点类* 添加子节点_已加锁(节点类* 父节点, 节点类* 子节点)
    {
        if (!父节点 || !子节点) return nullptr;

        子节点->父 = 父节点;

        // 父节点第一次拥有子链
        if (!父节点->子) {
            父节点->子 = 子节点;

            子节点->上 = 子节点;
            子节点->下 = 子节点;
            子节点->根 = 子节点;

            根指针->主键 = 子节点->主键 = 获取新主键(根指针->主键);

            父节点->变更子节点数量(1);
            更新链指针_已加锁(根指针, 子节点);
            return 子节点;
        }

        // 已有子链：插入到 父节点->子 的同层环里
        return 添加节点_已加锁(父节点->子, 子节点);
    }

    节点类* 添加子节点(节点类* 父节点, 节点类* 子节点)
    {
        std::lock_guard<std::recursive_mutex> lock(链表锁);
        return 添加子节点_已加锁(父节点, 子节点);
    }

    节点类* 添加子节点_已加锁(节点类* 父节点, 主信息类型 主信息)
    {
        auto* 子节点 = new 节点类{};
        子节点->主信息 = 主信息;
        return 添加子节点_已加锁(父节点, 子节点);
    }

    节点类* 添加子节点(节点类* 父节点, 主信息类型 主信息)
    {
        std::lock_guard<std::recursive_mutex> lock(链表锁);
        return 添加子节点_已加锁(父节点, 主信息);
    }

    // =============================================================
    // 3) 查找（全链扫描）
    // =============================================================

    节点类* 查找主键(const std::string& 主键) const
    {
        // 注意：若在多线程下使用，外部请先获取锁
        if (!根指针) return nullptr;
        节点类* 当前节点 = 根指针->链下;
        while (当前节点 && 当前节点 != 根指针) {
            if (当前节点->主键 == 主键) {
                return 当前节点;
            }
            当前节点 = 当前节点->链下;
        }
        return nullptr;
    }

    // =============================================================
    // 4) 修改节点信息
    // =============================================================

    // *_已加锁：调用者需已持有 链表锁
    void 修改节点信息_已加锁(节点类* 节点, 主信息类型 新信息)
    {
        if (!节点 || 节点 == 根指针) return;

        // 仅当主信息为“指针类型”时，认为节点独占其主信息，需要释放旧对象
        if constexpr (std::is_pointer_v<主信息类型>) {
            if (节点->主信息 != 新信息) {
                delete 节点->主信息;
                节点->主信息 = 新信息;
            }
        }
        else {
            节点->主信息 = 新信息;
        }
    }

    // 通过“节点指针”修改
    void 修改节点信息(节点类* 节点, 主信息类型 新信息)
    {
        std::lock_guard<std::recursive_mutex> lock(链表锁);
        修改节点信息_已加锁(节点, 新信息);
    }

    // 通过“主键”修改
    void 修改节点信息(const std::string& 主键, 主信息类型 新信息)
    {
        std::lock_guard<std::recursive_mutex> lock(链表锁);
        节点类* 节点 = 查找主键(主键);
        修改节点信息_已加锁(节点, 新信息);
    }

    // =============================================================
        // 5) 删除（支持递归删子链）
        // =============================================================

    void 删除节点_已加锁(节点类* 被删除节点)
    {
        if (!被删除节点 || 被删除节点 == 根指针) return;

        // 先递归删除子链（不会重复加锁）
        if (被删除节点->子) {
            删除子链_已加锁(被删除节点);
            被删除节点->子 = nullptr;
        }

        // 若父节点的 子 指针正指向该节点，需要提前修正
        if (被删除节点->父 && 被删除节点->父->子 == 被删除节点) {
            if (被删除节点->下 != 被删除节点) {
                被删除节点->父->子 = 被删除节点->下;
            }
            else {
                被删除节点->父->子 = nullptr;
            }
        }

        // 从同层环摘除
        被删除节点->上->下 = 被删除节点->下;
        被删除节点->下->上 = 被删除节点->上;

        // 从全链环摘除
        被删除节点->链上->链下 = 被删除节点->链下;
        被删除节点->链下->链上 = 被删除节点->链上;

        if (被删除节点->父) {
            被删除节点->父->变更子节点数量(-1);
        }

        if constexpr (std::is_pointer_v<主信息类型>) {
            delete 被删除节点->主信息;
            被删除节点->主信息 = nullptr;
        }

        delete 被删除节点;
    }

    void 删除节点(节点类* 被删除节点)
    {
        std::lock_guard<std::recursive_mutex> lock(链表锁);
        删除节点_已加锁(被删除节点);
    }

    void 删除子链_已加锁(节点类* 父节点)
    {
        if (!父节点 || !父节点->子) return;

        // 用“父->子 逐个前移”的方式安全删除环形子链
        while (父节点->子) {
            节点类* 当前 = 父节点->子;

            if (当前->下 == 当前) {
                // 单节点子链
                删除节点_已加锁(当前);
                父节点->子 = nullptr;
                break;
            }
            else {
                // 先把父->子移到下一个，避免删除时父->子悬空/循环条件失效
                父节点->子 = 当前->下;
                删除节点_已加锁(当前);
            }
        }
    }

    void 删除子链(节点类* 父节点)
    {
        std::lock_guard<std::recursive_mutex> lock(链表锁);
        删除子链_已加锁(父节点);
    }

    void 删除链表_已加锁()
    {
        if (!根指针) return;

        // 先删除所有顶层节点（会递归删除其子链）
        while (根指针->下 != 根指针) {
            删除节点_已加锁(根指针->下);
        }

        delete 根指针;
        根指针 = nullptr;
    }

    void 删除链表()
    {
        std::lock_guard<std::recursive_mutex> lock(链表锁);
        删除链表_已加锁();
    }

public:
    // =============================================================
    // 6) 按条件查找（当前链扫描示例：可按需扩展）
    // =============================================================
    节点类* 查找节点_当前链(主信息类型 查找内容) const
    {
        // 注意：若在多线程下使用，外部请先获取锁
        节点类* 当前节点 = 根指针 ? 根指针->链下 : nullptr;
        while (当前节点 && 当前节点 != 根指针) {
            auto 主信息 = dynamic_cast<主信息类型>(当前节点->主信息);
            if (主信息 && 主信息->比较(查找内容, 枚举_比较字段::主键, 枚举_比较条件::等于) == 0) {
                return 当前节点;
            }
            当前节点 = 当前节点->链下;
        }
        return nullptr;
    }
    节点类* 查找节点_当前链(节点类* 当前节点, const 主信息类型& 查找内容, 枚举_比较字段 字段选择, 枚举_比较条件 条件)
    {
        if (!当前节点) return nullptr;

        if (当前节点 == 根指针) {
            当前节点 = 当前节点->下;
            if (当前节点 == 根指针) return nullptr;
        }

        节点类* 起点 = 当前节点;
        do {
            if (dynamic_cast<主信息类型>(当前节点->主信息))
            {
                if (当前节点->主信息->比较(查找内容, 字段选择, 条件))
                    return 当前节点;
            }
            else {
                throw std::invalid_argument("逻辑错误,查找节点_当前链,主信息类型不符 ");
            }
            if (!当前节点) return nullptr;         // 保护：破链
            if (当前节点 == 根指针) return nullptr; // 到达哨兵，结束
        } while (当前节点 != 起点);

        return nullptr;
    }
};
