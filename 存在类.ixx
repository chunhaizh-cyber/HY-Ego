export module 存在模块;

import 主信息定义模块;
import 数据仓库模块;

import <vector>;
import <algorithm>;
import <stdexcept>;
import <cstdint>;

export class 存在类 {
public:
    //============================================================
    // 1) 创建/挂接：存在
    //============================================================

    // 创建一个存在节点并挂到场景（场景可为 nullptr，表示挂到宇宙根层）
    存在节点类* 创建并添加存在(场景节点类* 场景, 存在节点主信息类* 存在主信息 ) const
    {
        if (!存在主信息) return nullptr;
        auto* 新节点 = 世界链.添加子节点(场景, static_cast<基础信息基类*>(存在主信息));
        // 更新场景索引
        追加到场景存在索引(场景, 新节点);
        return static_cast<存在节点类*>(新节点);
    }

    // 兼容：将“已分配但未挂接”的存在节点挂到场景
    存在节点类* 添加存在(场景节点类* 场景, 存在节点类* 存在) const
    {
        if (!存在) return nullptr;
        auto* 新节点 = 世界链.添加子节点(场景, 存在);
        追加到场景存在索引(场景, 新节点);
        return static_cast<存在节点类*>(新节点);
    }

    //============================================================
    // 2) 创建/挂接：子存在（存在作为容器）
    //============================================================

    存在节点类* 创建并添加子存在(存在节点类* 父存在,存在节点主信息类* 子存在主信息 ) const
    {
        if (!父存在 || !子存在主信息) return nullptr;
        auto* 新节点 = 世界链.添加子节点(父存在, static_cast<基础信息基类*>(子存在主信息));
        // 更新父存在索引
        追加到父存在子存在索引(父存在, 新节点);
        return static_cast<存在节点类*>(新节点);
    }

    存在节点类* 添加子存在(存在节点类* 父存在, 存在节点类* 子存在) const
    {
        if (!父存在 || !子存在) return nullptr;
        auto* 新节点 = 世界链.添加子节点(父存在, 子存在);
        追加到父存在子存在索引(父存在, 新节点);
        return static_cast<存在节点类*>(新节点);
    }

    //============================================================
    // 3) 特征：添加/查找/删除
    //============================================================

    // 为存在添加一个“特征节点”（特征节点主信息由调用方构造，可带值也可不带）
    特征节点类* 为存在添加特征(存在节点类* 所属存在, 特征节点主信息类* 特征主信息) const
    {
        if (!所属存在 || !特征主信息) return nullptr;
        auto* 新节点 = 世界链.添加子节点(所属存在, static_cast<基础信息基类*>(特征主信息));
        // 更新索引 + 当前状态
        追加到父存在特征索引(所属存在, 新节点);
        return static_cast<特征节点类*>(新节点);
    }

    // 按“特征类型”查找当前特征（优先用缓存）
    特征节点类* 查找特征当前(存在节点类* 所属存在, 词性节点类* 特征类型) const
    {
        auto* mi = 取存在主信息(所属存在);
        if (!mi) return nullptr;
        return mi->查找特征当前(特征类型);
    }

    // 找到或创建某类型的特征节点（保证“同类型至少有一个”，但不强制删除旧的同类型节点）
    特征节点类* 找到或创建特征(存在节点类* 所属存在,词性节点类* 特征类型,词性节点类* 特征名称 = nullptr ) const
    {
        if (!所属存在 || !特征类型) return nullptr;

        // 1) 当前缓存
        if (auto* cur = 查找特征当前(所属存在, 特征类型)) return cur;

        // 2) 全量索引兜底
        auto* mi = 取存在主信息(所属存在);
        if (!mi) return nullptr;

        for (auto* f : mi->特征索引) {
            auto* fmi = 取特征主信息(f);
            if (fmi && fmi->类型 == 特征类型) {
                // 回填缓存
                mi->重建特征当前状态();
                return f;
            }
        }

        // 3) 创建
        auto* newFmi = new 特征节点主信息类(特征名称, 特征类型, /*值*/nullptr);
        return 为存在添加特征(所属存在, newFmi);
    }

    // 删除某类型的特征（默认删除“当前特征”；若没有当前则删索引中的第一个匹配）
    bool 删除特征(存在节点类* 所属存在, 词性节点类* 特征类型) const
    {
        if (!所属存在 || !特征类型) return false;
        auto* mi = 取存在主信息(所属存在);
        if (!mi) return false;

        特征节点类* target = mi->查找特征当前(特征类型);
        if (!target) {
            for (auto* f : mi->特征索引) {
                auto* fmi = 取特征主信息(f);
                if (fmi && fmi->类型 == 特征类型) { target = f; break; }
            }
        }
        if (!target) return false;

        // 维护 parent->子 指针（链表模板::删除节点 不会自动修正 parent->子）
        修正父节点子指针_在删除前(target);

        // 先从索引移除（避免悬挂指针）
        移除指针(mi->特征索引, target);
        移除指针(mi->特征当前状态, target);

        世界链.删除节点(target);

        // 重建当前状态缓存（同类型可能还有其它特征节点）
        mi->重建特征当前状态();
        return true;
    }

    //============================================================
    // 4) 索引维护：从子链重建（容灾/批量修改后）
    //============================================================

    void 重建索引_从子链(存在节点类* 所属存在) const
    {
        if (!所属存在) return;
        auto* mi = 取存在主信息(所属存在);
        if (!mi) return;

        mi->子存在索引.clear();
        mi->特征索引.clear();

        if (!所属存在->子) {
            mi->特征当前状态.clear();
            return;
        }

        auto* 起 = 所属存在->子;
        auto* 游 = 起;
        do {
            if (!游 || !游->主信息) break;

            if (dynamic_cast<存在节点主信息类*>(游->主信息)) {
                mi->子存在索引.push_back(static_cast<存在节点类*>(游));
            }
            else if (dynamic_cast<特征节点主信息类*>(游->主信息)) {
                mi->特征索引.push_back(static_cast<特征节点类*>(游));
            }

            游 = 游->下;
        } while (游 && 游 != 起);

        mi->重建特征当前状态();
    }

    //============================================================
    // 5) 删除：子存在（同样要维护 parent->子 指针 + 索引）
    //============================================================

    bool 删除子存在(存在节点类* 父存在, 存在节点类* 子存在) const
    {
        if (!父存在 || !子存在) return false;
        auto* mi = 取存在主信息(父存在);
        if (!mi) return false;

        // 只有确实是父子关系才删
        if (子存在->父 != 父存在) return false;

        修正父节点子指针_在删除前(子存在);
        移除指针(mi->子存在索引, 子存在);

        世界链.删除节点(子存在);

        return true;
    }

private:
    //============================================================
    // 内部工具
    //============================================================

    static 存在节点主信息类* 取存在主信息(const 存在节点类* n)
    {
        if (!n || !n->主信息) return nullptr;
        return dynamic_cast<存在节点主信息类*>(n->主信息);
    }

    static 特征节点主信息类* 取特征主信息(const 特征节点类* n)
    {
        if (!n || !n->主信息) return nullptr;
        return dynamic_cast<特征节点主信息类*>(n->主信息);
    }

    static void 追加到场景存在索引(场景节点类* 场景, 基础信息节点类* 存在节点)
    {
        if (!场景 || !存在节点 || !场景->主信息) return;
        auto* smi = dynamic_cast<场景节点主信息类*>(场景->主信息);
        if (!smi) return;
        smi->存在索引.push_back(static_cast<存在节点类*>(存在节点));
    }

    static void 追加到父存在子存在索引(存在节点类* 父存在, 基础信息节点类* 子存在)
    {
        auto* pmi = 取存在主信息(父存在);
        if (!pmi || !子存在) return;
        pmi->子存在索引.push_back(static_cast<存在节点类*>(子存在));
    }

    static void 追加到父存在特征索引(存在节点类* 父存在, 基础信息节点类* 特征节点)
    {
        auto* pmi = 取存在主信息(父存在);
        if (!pmi || !特征节点) return;

        auto* f = static_cast<特征节点类*>(特征节点);
        pmi->特征索引.push_back(f);

        // 增量更新“当前状态”：若该类型没有当前，则加入
        if (auto* fmi = 取特征主信息(f)) {
            if (!pmi->查找特征当前(fmi->类型)) {
                pmi->特征当前状态.push_back(f);
            }
        }
    }

    template <class T>
    static void 移除指针(std::vector<T*>& v, T* p)
    {
        v.erase(std::remove(v.begin(), v.end(), p), v.end());
    }

    // 重要：链表模板::删除节点 不会自动维护 parent->子 指针。
    // 删除前如果 target 正好是 parent->子，需要把 parent->子 指向下一个或置空。
    static void 修正父节点子指针_在删除前(基础信息节点类* target)
    {
        if (!target) return;
        auto* parent = target->父;
        if (!parent) return;
        if (parent->子 != target) return;

        // 目标是唯一子节点
        if (target->下 == target) {
            parent->子 = nullptr;
            return;
        }

        // 还有其它兄弟：让 parent->子 指向一个仍存活的兄弟
        parent->子 = target->下;
    }
};
