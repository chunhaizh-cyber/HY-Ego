export module 三维场景管模块;

import <cmath>;
import <vector>;
import <algorithm>;
import <limits>;
import <cstdint>;
import 基础数据类型模块;
import 主信息定义模块;
import 世界树模块;
import 语素模块;
import 相机接口模块;
import 宇宙环境模块;
import 宇宙链模块;
import 特征值模块;  // 新增：用于特征值集



// ========== 场景3D管理器 ==========
export class 三维场景管理类 {
public:
    三维场景管理类(世界树类& 世界树, 场景节点类* 当前场景)
        : 世界树(世界树), 当前场景(当前场景) {    }

    // 将一帧所有存在观测融合进入场景
    void 融合存在观测列表(const std::vector<结构体_存在观测>& 列表) {

        for (const auto& obs : 列表) {
            存在节点类* 存在节点 = 找到或创建存在(obs);
            if (存在节点) {
                更新存在信息(存在节点, obs);
            }
        }
    }

private:
    世界树类& 世界树;
    场景节点类* 当前场景 = nullptr;

    // ========= 查找或创建存在 =========
    存在节点类* 找到或创建存在(const 结构体_存在观测& 观测);

    // ========= 更新存在动态信息 =========
    void 更新存在信息(存在节点类* 存在, const 结构体_存在观测& 观测);

    // ========= 相似度（预留扩展）=========
    double 计算相似度(const 结构体_存在观测& o, 存在节点类* 已知存在);

    // ========= 辅助函数 =========
public:
    // 检查某个轴特征的所有标量值是否至少有一个落在 [min, max] 范围内
    static bool 轴特征值在范围内(存在节点类* 存在, 词性节点类* 类型, double minVal, double maxVal) {
        特征节点类* feat = g_宇宙.世界树.查找特征节点(存在, 类型);
        if (!feat) return false;

        auto* info = dynamic_cast<特征节点主信息类*>(feat->主信息);
        if (!info || !info->值) return false;

        特征值节点类* val = info->值;
        do {
            if (auto* scalar = dynamic_cast<标量特征值主信息类*>(val->主信息)) {
                double v = scalar->值 / 1000.0;  // 存储为毫米整数
                if (v >= minVal && v <= maxVal) return true;
            }
            val = val->下;
        } while (val != info->值);

        return false;
    }

    // 取该轴所有特征值中距离目标最近的一个值
    static void 轴取最近值(存在节点类* 存在, 词性节点类* 类型, double 目标, double& 出值) {
        特征节点类* feat = g_宇宙.世界树.查找特征节点(存在, 类型);
        if (!feat) return;

        auto* info = dynamic_cast<特征节点主信息类*>(feat->主信息);
        if (!info || !info->值) return;

        double bestDiff = std::numeric_limits<double>::infinity();
        特征值节点类* val = info->值;
        do {
            if (auto* scalar = dynamic_cast<标量特征值主信息类*>(val->主信息)) {
                double v = scalar->值 / 1000.0;
                double diff = std::abs(v - 目标);
                if (diff < bestDiff) {
                    bestDiff = diff;
                    出值 = v;
                }
            }
            val = val->下;
        } while (val != info->值);
    }

    // 判断是否存在中是否已有完全相同的轮廓值节点（指针比较）
    static bool 存在已有相同轮廓值(存在节点类* 存在, 词性节点类* 类型, 特征值节点类* 目标轮廓值节点) {
        特征节点类* feat = g_宇宙.世界树.查找特征节点(存在, 类型);
        if (!feat) return false;

        auto* info = dynamic_cast<特征节点主信息类*>(feat->主信息);
        if (!info || !info->值) return false;

        特征值节点类* val = info->值;
        do {
            if (val == 目标轮廓值节点) return true;
            val = val->下;
        } while (val != info->值);

        return false;
    }
};

// ========== 找到或创建存在 实现 ==========
存在节点类* 三维场景管理类::找到或创建存在(const 结构体_存在观测& 观测)
{
    // 0) 确保当前场景有效
    if (!当前场景) {
        当前场景 = (场景节点类*)g_宇宙.世界树.自我所在场景;
    }
    if (!当前场景) {
        return nullptr;
    }

    // =========================================================
    // 1) 静态特征类型词（一次性创建）
    // =========================================================
    static 词性节点类* T_位置X = nullptr;
    static 词性节点类* T_位置Y = nullptr;
    static 词性节点类* T_位置Z = nullptr;
    static 词性节点类* T_尺寸左右 = nullptr;
    static 词性节点类* T_尺寸上下 = nullptr;
    static 词性节点类* T_尺寸前后 = nullptr;
    static 词性节点类* T_轮廓 = nullptr;

    if (!T_位置X) {
        T_位置X = 语素集.添加词性词("位置坐标X轴", "名词");
        T_位置Y = 语素集.添加词性词("位置坐标Y轴", "名词");
        T_位置Z = 语素集.添加词性词("位置坐标Z轴", "名词");
        T_尺寸左右 = 语素集.添加词性词("尺寸_左右", "名词");
        T_尺寸上下 = 语素集.添加词性词("尺寸_上下", "名词");
        T_尺寸前后 = 语素集.添加词性词("尺寸_前后", "名词");
        T_轮廓 = 语素集.添加词性词("轮廓", "名词");
    }

    // =========================================================
    // 2) 计算位置搜索范围（中心 ± 尺寸/2 + 容差）
    // =========================================================
    constexpr double k最小半径_m = 0.0;
    constexpr double k位置容差_m = 0.0;

    const Vector3D halfSize = 观测.尺寸 * 0.5;
    const double radiusX = std::max(halfSize.x + k位置容差_m, k最小半径_m);
    const double radiusY = std::max(halfSize.y + k位置容差_m, k最小半径_m);
    const double radiusZ = std::max(halfSize.z + k位置容差_m, k最小半径_m);

    const double minX = 观测.中心坐标.x - radiusX;
    const double maxX = 观测.中心坐标.x + radiusX;
    const double minY = 观测.中心坐标.y - radiusY;
    const double maxY = 观测.中心坐标.y + radiusY;
    const double minZ = 观测.中心坐标.z - radiusZ;
    const double maxZ = 观测.中心坐标.z + radiusZ;

    // =========================================================
    // 3) 获取轮廓编码（全局查重）
    // =========================================================
    特征值节点类* 轮廓值节点 = nullptr;
    if (!观测.轮廓编码.empty()) {
        轮廓值节点 = 特征值集.获取或创建矢量特征值(观测.轮廓编码);
    }

    // =========================================================
    // 4) 收集位置命中的候选存在
    // =========================================================
    std::vector<存在节点类*> 位置命中列表;

    基础信息节点类* child = 当前场景->子;
    if (child) {
        基础信息节点类* cur = child;
        do {
            if (auto* exist = dynamic_cast<存在节点类*>(cur)) {
                if (轴特征值在范围内(exist, T_位置X, minX, maxX) &&
                    轴特征值在范围内(exist, T_位置Y, minY, maxY) &&
                    轴特征值在范围内(exist, T_位置Z, minZ, maxZ)) {
                    位置命中列表.push_back(exist);
                }
            }
            cur = cur->下;
        } while (cur != child);
    }

    // =========================================================
    // 5) （可选）轮廓进一步筛选
    // =========================================================
    std::vector<存在节点类*> 候选集 = 位置命中列表;
    if (轮廓值节点) {
        std::vector<存在节点类*> 轮廓命中;
        for (auto* e : 位置命中列表) {
            if (存在已有相同轮廓值(e, T_轮廓, 轮廓值节点)) {
                轮廓命中.push_back(e);
            }
        }
        if (!轮廓命中.empty()) {
            候选集 = 轮廓命中;
        }
    }

    // =========================================================
    // 6) 选距离最近的作为最佳匹配
    // =========================================================
    存在节点类* 最佳匹配 = nullptr;
    double       最佳距离 = std::numeric_limits<double>::infinity();

    for (auto* e : 候选集) {
        double closestX = 观测.中心坐标.x;
        double closestY = 观测.中心坐标.y;
        double closestZ = 观测.中心坐标.z;

        轴取最近值(e, T_位置X, 观测.中心坐标.x, closestX);
        轴取最近值(e, T_位置Y, 观测.中心坐标.y, closestY);
        轴取最近值(e, T_位置Z, 观测.中心坐标.z, closestZ);

        double dx = closestX - 观测.中心坐标.x;
        double dy = closestY - 观测.中心坐标.y;
        double dz = closestZ - 观测.中心坐标.z;
        double dist = std::sqrt(dx * dx + dy * dy + dz * dz);

        if (dist < 最佳距离) {
            最佳距离 = dist;
            最佳匹配 = e;
        }
    }

    // =========================================================
    // 7) 无匹配 → 创建新存在并写入初始特征
    // =========================================================
    if (!最佳匹配) {
        auto* 新存在主信息 = new 存在节点主信息类();
        最佳匹配 = 世界树.新建存在(当前场景, 新存在主信息);

        // 写入位置（毫米整数）
        世界树.为存在添加特征(最佳匹配,
            new 特征节点主信息类(T_位置X, T_位置X,
                特征值集.获取或创建标量特征值(nullptr, static_cast<int64_t>(观测.中心坐标.x * 1000))));
        世界树.为存在添加特征(最佳匹配,
            new 特征节点主信息类(T_位置Y, T_位置Y,
                特征值集.获取或创建标量特征值(nullptr, static_cast<int64_t>(观测.中心坐标.y * 1000))));
        世界树.为存在添加特征(最佳匹配,
            new 特征节点主信息类(T_位置Z, T_位置Z,
                特征值集.获取或创建标量特征值(nullptr, static_cast<int64_t>(观测.中心坐标.z * 1000))));

        // 写入尺寸
        世界树.为存在添加特征(最佳匹配,
            new 特征节点主信息类(T_尺寸左右, T_尺寸左右,
                特征值集.获取或创建标量特征值(nullptr, static_cast<int64_t>(观测.尺寸.x * 1000))));
        世界树.为存在添加特征(最佳匹配,
            new 特征节点主信息类(T_尺寸上下, T_尺寸上下,
                特征值集.获取或创建标量特征值(nullptr, static_cast<int64_t>(观测.尺寸.y * 1000))));
        世界树.为存在添加特征(最佳匹配,
            new 特征节点主信息类(T_尺寸前后, T_尺寸前后,
                特征值集.获取或创建标量特征值(nullptr, static_cast<int64_t>(观测.尺寸.z * 1000))));

        // 写入轮廓
        if (轮廓值节点) {
            世界树.为存在添加特征(最佳匹配,
                new 特征节点主信息类(T_轮廓, T_轮廓, 轮廓值节点));
        }

        return 最佳匹配;
    }

    // =========================================================
    // 8) 已有匹配 → 引用次数+1，处理轮廓
    // =========================================================
    最佳匹配->变更节点被引用次数(1);

    if (轮廓值节点) {
        特征节点类* 轮廓特征节点 = g_宇宙.世界树.查找特征节点(最佳匹配, T_轮廓);

        if (!轮廓特征节点) {
            // 首次出现轮廓特征
            世界树.为存在添加特征(最佳匹配,
                new 特征节点主信息类(T_轮廓, T_轮廓, 轮廓值节点));
        }
        else {
            // 检查是否已有相同轮廓值
            if (存在已有相同轮廓值(最佳匹配, T_轮廓, 轮廓值节点)) {
                // 相同 → 特征节点引用次数 +1
                轮廓特征节点->变更节点被引用次数(1);
            }
            else {
                // 不同 → 追加到值环
                auto* info = dynamic_cast<特征节点主信息类*>(轮廓特征节点->主信息);
                if (info && info->值) {
                    g_宇宙.世界树.为存在添加特征(最佳匹配, info);
                }
            }
        }
    }

    return 最佳匹配;
}

void 三维场景管理类::更新存在信息(存在节点类* 存在, const 结构体_存在观测& 观测)
{
    // =========================================================
    // 静态词性缓存（一次性创建，避免重复查找）
    // =========================================================
    static 词性节点类* T_最近观测时间 = nullptr;
    static 词性节点类* T_平均颜色 = nullptr;
    static 词性节点类* T_观测次数 = nullptr;

    if (!T_最近观测时间) {
        T_最近观测时间 = 语素集.添加词性词("最近观测时间", "名词");
        T_平均颜色 = 语素集.添加词性词("平均颜色", "名词");       // RGB 打包为 32bit 整数
        T_观测次数 = 语素集.添加词性词("观测次数", "名词");       // 用于加权平均或置信度
    }

    // =========================================================
    // 1) 更新最近观测时间（毫秒时间戳，支持排序与超时清理）
    // =========================================================
    int64_t 当前时间戳_ms =  观测.时间;  // 假设 结构体_时间戳 有此方法

    世界树.为存在添加特征(存在,
        new 特征节点主信息类(T_最近观测时间, T_最近观测时间,
            特征值集.获取或创建标量特征值(nullptr, 当前时间戳_ms)));

    // =========================================================
    // 2) 更新平均颜色（累计加权平均，保持颜色稳定）
    // =========================================================
    if (观测.平均颜色.r + 观测.平均颜色.g + 观测.平均颜色.b > 0)  // 有效颜色
    {
        uint32_t 新颜色RGB = (static_cast<uint32_t>(观测.平均颜色.r) << 16) |
            (static_cast<uint32_t>(观测.平均颜色.g) << 8) |
            static_cast<uint32_t>(观测.平均颜色.b);

        // 获取历史观测次数（若无则为0）
        int64_t 历史次数 = 0;
        特征节点类* 次数特征 = g_宇宙.世界树.查找特征节点(存在, T_观测次数);
        if (次数特征) {
            auto* info = dynamic_cast<特征节点主信息类*>(次数特征->主信息);
            if (info && info->值) {
                if (auto* scalar = dynamic_cast<标量特征值主信息类*>(info->值->主信息)) {
                    历史次数 = scalar->值;
                }
            }
        }

        // 获取历史平均颜色（若无则用当前颜色）
        uint32_t 历史颜色 = 新颜色RGB;
        特征节点类* 颜色特征 = g_宇宙.世界树.查找特征节点(存在, T_平均颜色);
        if (颜色特征) {
            auto* info = dynamic_cast<特征节点主信息类*>(颜色特征->主信息);
            if (info && info->值) {
                if (auto* scalar = dynamic_cast<标量特征值主信息类*>(info->值->主信息)) {
                    历史颜色 = static_cast<uint32_t>(scalar->值);
                }
            }
        }

        // 加权平均：新颜色权重为 1，历史权重为 历史次数
        int64_t 新次数 = 历史次数 + 1;
        uint32_t 平均颜色 = static_cast<uint32_t>(
            (static_cast<uint64_t>(历史颜色) * 历史次数 + 新颜色RGB) / 新次数
            );

        // 写入更新后的平均颜色和观测次数
        世界树.为存在添加特征(存在,
            new 特征节点主信息类(T_平均颜色, T_平均颜色,
                特征值集.获取或创建标量特征值(nullptr, static_cast<int64_t>(平均颜色))));

        世界树.为存在添加特征(存在,
            new 特征节点主信息类(T_观测次数, T_观测次数,
                特征值集.获取或创建标量特征值(nullptr, 新次数)));
    }

    // =========================================================
    // 3) 可选：更新尺寸（取历史最大值或滑动平均，视需求）
    // =========================================================
    // 如果你希望“存在”记住自己最大尺寸（例如人伸展时），可在这里追加类似逻辑
    // 目前不实现，保持尺寸由“找到或创建”时写入初始值为主
}

double 三维场景管理类::计算相似度(const 结构体_存在观测& o, 存在节点类* 已知存在)
{
    // =========================================================
    // 静态词性缓存
    // =========================================================
    static 词性节点类* T_位置X = 语素集.添加词性词("位置坐标X轴", "名词");
    static 词性节点类* T_位置Y = 语素集.添加词性词("位置坐标Y轴", "名词");
    static 词性节点类* T_位置Z = 语素集.添加词性词("位置坐标Z轴", "名词");
    static 词性节点类* T_尺寸左右 = 语素集.添加词性词("尺寸_左右", "名词");
    static 词性节点类* T_尺寸上下 = 语素集.添加词性词("尺寸_上下", "名词");
    static 词性节点类* T_尺寸前后 = 语素集.添加词性词("尺寸_前后", "名词");
    static 词性节点类* T_轮廓 = 语素集.添加词性词("轮廓", "名词");

    double 总相似度 = 0.0;
    double 权重和 = 0.0;

    // =========================================================
    // 1) 位置相似度（越近越相似，指数衰减）
    // =========================================================
    double closestX = o.中心坐标.x;
    double closestY = o.中心坐标.y;
    double closestZ = o.中心坐标.z;

    轴取最近值(已知存在, T_位置X, o.中心坐标.x, closestX);
    轴取最近值(已知存在, T_位置Y, o.中心坐标.y, closestY);
    轴取最近值(已知存在, T_位置Z, o.中心坐标.z, closestZ);

    double 位置距离 = std::sqrt(
        (closestX - o.中心坐标.x) * (closestX - o.中心坐标.x) +
        (closestY - o.中心坐标.y) * (closestY - o.中心坐标.y) +
        (closestZ - o.中心坐标.z) * (closestZ - o.中心坐标.z)
    );

    constexpr double k位置特征尺度 = 0.5;  // 距离超过0.5米相似度快速衰减
    double 位置相似度 = std::exp(-位置距离 / k位置特征尺度);

    总相似度 += 位置相似度 * 40.0;  // 位置权重最高
    权重和 += 40.0;

    // =========================================================
    // 2) 尺寸相似度（相对比例）
    // =========================================================
    Vector3D 历史尺寸{ 0.1, 0.1, 0.1 };  // 防除零
    // 取最近一次记录的尺寸（或最大尺寸，视需求）
    double temp;
    if (轴特征值在范围内(已知存在, T_尺寸左右, 0.001, 10.0)) {
        轴取最近值(已知存在, T_尺寸左右, o.尺寸.x, temp);
        历史尺寸.x = temp;
    }
    if (轴特征值在范围内(已知存在, T_尺寸上下, 0.001, 10.0)) {
        轴取最近值(已知存在, T_尺寸上下, o.尺寸.y, temp);
        历史尺寸.y = temp;
    }
    if (轴特征值在范围内(已知存在, T_尺寸前后, 0.001, 10.0)) {
        轴取最近值(已知存在, T_尺寸前后, o.尺寸.z, temp);
        历史尺寸.z = temp;
    }

    double 尺寸比率 = (o.尺寸.x / 历史尺寸.x + o.尺寸.y / 历史尺寸.y + o.尺寸.z / 历史尺寸.z) / 3.0;
    double 尺寸相似度 = std::exp(-std::abs(尺寸比率 - 1.0) * 3.0);  // 偏差20%时相似度≈0.55

    总相似度 += 尺寸相似度 * 20.0;
    权重和 += 20.0;

    // =========================================================
    // 3) 轮廓相似度（若有精确匹配则满分，否则0或后续模糊匹配）
    // =========================================================
    if (!o.轮廓编码.empty()) {
        特征值节点类* 新轮廓节点 = 特征值集.获取或创建矢量特征值(o.轮廓编码);
        if (存在已有相同轮廓值(已知存在, T_轮廓, 新轮廓节点)) {
            总相似度 += 1.0 * 40.0;  // 轮廓完全一致，最高奖励
            权重和 += 40.0;
        }
        // 未来可在此加入模糊相似度（如汉明距离）
    }

    // =========================================================
    // 返回归一化相似度 [0.0, 1.0]
    // =========================================================
    return 权重和 > 0.0 ? 总相似度 / 权重和 : 0.0;
}