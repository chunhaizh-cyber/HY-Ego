// 观察模块.ixx（纯函数式观察工具）
export module 观察模块;

import <vector>;
import <optional>;

import 基础数据类型模块;
import 点簇分割模块;
import 存在提取模块;
import 三维场景管理模块;    // 只用于单位转换工具（可选）
import 特征类型定义模块;   // 类型_位置X 等全局特征类型
import 特征值环境模块;      // 特征值集（全局仓库）
import 主信息定义模块;
import 世界树环境模块;

export struct 观察参数
{
    // 分割参数（仅在输入原始帧时使用）
    点簇分割参数 分割参数{};

    // 提取参数
    观测提取参数 提取参数{};

    // 是否强制将米转为毫米（建议在上层相机阶段完成，这里保留兼容）
    bool 强制毫米单位 = false;

    // 是否返回质量相关特征（深度噪声、PCA残差等）
    bool 输出质量特征 = true;

    // 是否输出主方向特征
    bool 输出主方向特征 = true;
};

export class 观察类
{
private:
    存在提取类 _提取器;  // 无状态，可共享

public:
    观察类() = default;

    // ==================================================
    // 1. 最常用：从原始场景帧观察 → 返回所有检测到目标的特征值列表
    // ==================================================
    [[nodiscard]]
    std::vector<std::vector<特征值节点类*>> 观察场景帧(
        const 结构体_原始场景帧& 帧,
        const 观察参数& 参数 = {}) const
    {
        std::vector<std::vector<特征值节点类*>> 所有目标特征;

        // 步骤1：点簇分割 + 增强（推荐直接获取增强结果）
        std::vector<点簇增强结果> 增强列表 = 点簇分割类{}.分割点簇_增强(帧, 参数.分割参数);
        // 如果您的分割类是单例或全局，可改为全局调用

        if (增强列表.empty())
            return 所有目标特征;

        // 步骤2：批量提取存在观测
        std::vector<结构体_存在观测> 观测列表 =
            _提取器.从点簇增强列表提取观测(增强列表, 参数.提取参数);

        // 步骤3：为每个观测生成特征值集合
        for (auto& obs : 观测列表)
        {
            所有目标特征.push_back(生成目标特征值(obs, 参数));
        }

        return 所有目标特征;
    }

    // ==================================================
    // 2. 从单个点簇增强结果观察 → 返回该目标的特征值列表
    // ==================================================
    [[nodiscard]]
    std::optional<std::vector<特征值节点类*>> 观察单目标(
        const 点簇增强结果& 增强结果,
        const 观察参数& 参数 = {}) const
    {
        结构体_存在观测 obs;
        if (!_提取器.从点簇增强提取存在观测(增强结果, obs, 参数.提取参数))
            return std::nullopt;

        return 生成目标特征值(obs, 参数);
    }

    // ==================================================
    // 3. 从已提取的存在观测直接观察（最轻量）
    // ==================================================
    [[nodiscard]]
    std::vector<特征值节点类*> 观察已知观测(
        const 结构体_存在观测& 观测,
        const 观察参数& 参数 = {}) const
    {
        return 生成目标特征值(观测, 参数);
    }

private:
    // 核心：将一个 结构体_存在观测 转换为特征值节点指针列表
    [[nodiscard]]
    static std::vector<特征值节点类*> 生成目标特征值(
        const 结构体_存在观测& obs,
        const 观察参数& 参数)
    {
        std::vector<特征值节点类*> 特征列表;

        auto 添加标量 = [&](词性节点类* 类型, double 值米)
            {
                std::int64_t 值mm = 三维场景管理类::米到毫米(参数.强制毫米单位 ? 值米 : 值米);
                auto* v = 特征值集.获取或创建标量特征值(nullptr, 值mm);
          //      特征列表.push_back(世界树.为存在添加特征(类型, v));  // 假设有临时添加接口，或直接返回v
                // 如果不需要挂树，可直接 push_back(v);
            };

        // === 绝对位置 ===
        添加标量(类型_位置X, obs.中心坐标.x);
        添加标量(类型_位置Y, obs.中心坐标.y);
        添加标量(类型_位置Z, obs.中心坐标.z);

        // === 尺寸 ===
        添加标量(类型_尺寸左右, obs.尺寸.x);
        添加标量(类型_尺寸上下, obs.尺寸.y);
        添加标量(类型_尺寸前后, obs.尺寸.z);

        // === 平均颜色 ===
        if (obs.平均颜色.r + obs.平均颜色.g + obs.平均颜色.b > 30) // 排除噪声纯白/黑
        {
            颜色_BGR8 col{ obs.平均颜色.b, obs.平均颜色.g, obs.平均颜色.r };
            auto* v = 特征值集.获取或创建颜色特征值(col);
            特征列表.push_back(v);
            // 如果需要挂到特征节点：世界树.为临时添加特征(类型_平均颜色, v);
        }

        // === 轮廓编码 ===
        if (!obs.轮廓编码.empty() && obs.轮廓编码.size() == 1)
        {
            Bits64 bits;
            bits.w = obs.轮廓编码[0];
            auto* v = 特征值集.获取或创建位图特征值(bits);
            特征列表.push_back(v);
        }

        // === 主方向（可选）===
        if (参数.输出主方向特征 &&
            (obs.主方向1.x != 0 || obs.主方向1.y != 0 || obs.主方向1.z != 0))
        {
            auto 添加方向 = [&](词性节点类* 类型, const Vector3D& dir)
                {
                    std::vector<float> vec = { (float)dir.x, (float)dir.y, (float)dir.z };
                    auto* v = 特征值集.获取或创建向量特征值_f32(vec);
                    特征列表.push_back(v);
                };

            添加方向(类型_主方向1, obs.主方向1);
            添加方向(类型_主方向2, obs.主方向2);
            添加方向(类型_主方向3, obs.主方向3);
        }

        // === 质量特征（可选）===
        if (参数.输出质量特征)
        {
            添加标量(类型_观测质量分, obs.质量分);
            添加标量(类型_深度噪声_MAD, obs.深度噪声_MAD);
            添加标量(类型_PCA残差, obs.PCA残差);
            添加标量(类型_颜色一致性, obs.颜色一致性);
       //     添加标量(类型_有效点比例, obs.有效点比例);
        }

        return 特征列表;
    }
};