// 世界树模块.ixx
export module 世界树模块;
import <vector> ;
import 基础数据类型模块;
import 主信息定义模块; 
import 语素模块;
import 数据仓库模块;
import 场景模块;
import 存在模块;
import 特征模块;


export class 世界树类 {
public:
    using 节点类型 = 基础信息节点类;
    场景节点类* 现实世界 = nullptr;  // 现实世界根场景（在 世界链 上的一棵子树）   
    场景节点类* 文本世界 = nullptr;
    场景节点类* 想象世界 = nullptr;
    场景节点类* 记忆世界 = nullptr;
    场景节点类* 推理世界 = nullptr;
    场景节点类* 内部世界 = nullptr;
    场景节点类* 虚拟世界 = nullptr;    
    存在节点类* 自我指针 = nullptr;
    场景节点类* 自我所在场景 = nullptr;
private:
    语素类 语素操作;
  static inline  场景类 场景集;
  static inline  存在类 存在集;
  static inline  特征类 特征集;
    
public:
    世界树类() = default;
    ~世界树类() = default;

    世界树类(const 世界树类&) = delete;
    世界树类& operator=(const 世界树类&) = delete;
    世界树类(世界树类&&) = default;
    世界树类& operator=(世界树类&&) = default;

    // 初始化默认世界
    void 初始化默认世界(时间戳 now = 0)
    {
        // 1) 根层世界场景
        auto mkName = [&](const char* s) -> 词性节点类* {
            return 语素操作.添加词性词(std::string(s), "专有名词");
            };

        现实世界 = 场景集.创建并添加场景(/*父=*/nullptr, mkName("现实世界"), 枚举_世界类型::现实世界, now);
        文本世界 = 场景集.创建并添加场景(/*父=*/nullptr, mkName("文本世界"), 枚举_世界类型::文本世界, now);
        想象世界 = 场景集.创建并添加场景(/*父=*/nullptr, mkName("想象世界"), 枚举_世界类型::想象世界, now);
        记忆世界 = 场景集.创建并添加场景(/*父=*/nullptr, mkName("记忆世界"), 枚举_世界类型::记忆世界, now);
        推理世界 = 场景集.创建并添加场景(/*父=*/nullptr, mkName("推理世界"), 枚举_世界类型::推理世界, now);
        内部世界 = 场景集.创建并添加场景(/*父=*/nullptr, mkName("内部世界"), 枚举_世界类型::内部世界, now);
        虚拟世界 = 场景集.创建并添加场景(/*父=*/nullptr, mkName("虚拟世界"), 枚举_世界类型::虚拟世界, now);

        // 2) 自我场景 + 自我存在
        自我所在场景 = 场景集.创建并添加场景(现实世界, mkName("自我场景"), 枚举_世界类型::现实世界, now);
        自我指针 = 存在集.创建并添加存在(自我所在场景, new 存在节点主信息类());
    }

    //生成一个空白场景,并放在世界树根链上,可以有许多,会定期清除
    场景节点类* 添加场景(const std::string& 名称, 场景节点类* 父场景, 枚举_世界类型 世界类型 = 枚举_世界类型::现实世界, 时间戳 now = 0)
    {
        词性节点类* 名称词性节点 = 语素操作.添加词性词(名称, "专有名词");
        return 场景集.创建并添加场景(父场景, 名称词性节点, 世界类型, now);
    }
	//根据名称和上级场景生成一个新场景
    场景节点类* 添加场景(std::string 名称,场景节点类* 父场景 ) {
        
        auto* 主信息 = new 场景节点主信息类();
		词性节点类* 名称词性节点 = 语素操作.添加词性词(名称, "专有名词");
        主信息->名称 = 名称词性节点;		
        基础信息基类* 基类指针 = 主信息;
        auto* 节点 = 世界链.添加子节点(父场景, 基类指针);        
        return 节点;
	}

	场景节点类* 为存在添加内部世界(存在节点类* 存在, 场景节点主信息类* 内部世界主信息);

    场景节点类* 为场景添加存在(场景节点类* 场景, 存在节点主信息类* 存在主信息);

    // 在某个场景下新建一个“存在实例”
    存在节点类* 在场景中新建存在(场景节点类* 所在场景, 存在节点主信息类* 主信息);
    存在节点类* 在场景查找存在(场景节点类* 所在场景, 存在节点主信息类* 主信息);
    存在节点类* 在场景查找存在(场景节点类* 所在场景, 存在节点类* 存在节点指针);

    // 给某个存在实例挂一个特征（颜色、形状、位置等）
    特征节点类* 为存在添加特征(存在节点类* 存在, 特征节点主信息类* 特征主信息);
	
    // 查找某个存在下，指定类型 + 指定值的特征节点（精确匹配）
    特征节点类* 查找特征节点_类型加值(存在节点类* 存在,词性节点类* 特征类型,特征值节点类* 目标特征值) const;

    // 检查某个存在是否已经拥有某个具体特征值（常用于查重）
    bool 是否存在该特征值(存在节点类* 存在, 词性节点类* 特征类型, 特征值节点类* 目标特征值) const;

    // 只按类型查找（返回第一个匹配的特征节点）—— 仍保留，用于读取“当前最新”或“唯一”特征的情况
    特征节点类* 在存在中查找特征类型(存在节点类* 存在, 词性节点类* 特征类型) const;

    // （可选）返回指定类型的所有特征节点（如果一个类型允许多个独立特征节点）
    std::vector<特征节点类*> 查找所有特征节点(存在节点类* 存在, 词性节点类* 特征类型) const;

    //============================================================
       // 观测驱动接口（对外更自然的入口）
       //============================================================

    struct 结构体_观测融合参数
    {
        // 位置/尺寸匹配用
        结构体_场景存在匹配参数 匹配参数{};

        // 可选：轮廓编码（矢量特征）类型
        词性节点类* 轮廓特征类型 = nullptr;

        // 写入策略
        bool 位置尺寸使用融合 = false; // false=覆盖, true=融合
        bool 轮廓使用融合 = false;

        // 融合参数（若开启融合）
        特征值类::融合参数 融合参数{};
    };

    // 观测到一个存在：先在场景中查找，再更新（位置/尺寸/轮廓），找不到则创建
    存在节点类* 观测到存在(
        场景节点类* 场景,
        const Vector3D& 中心坐标,
        const Vector3D& 尺寸坐标,
        const std::vector<std::int64_t>& 轮廓编码,
        const 结构体_观测融合参数& p,
        时间戳 now = 0);

    // 模板版：只要你的观测结构体包含 字段: 中心坐标/尺寸/轮廓编码（以及可选 时间）即可直接调用
    template<class T观测>
        requires requires(const T观测& o) {
        o.中心坐标; o.尺寸; o.轮廓编码;
    }
    存在节点类* 观测到存在(场景节点类* 场景, const T观测& 观测, const 结构体_观测融合参数& p)
    {
        时间戳 now = 0;
        if constexpr (requires { 观测.时间; }) {
            now = static_cast<时间戳>(观测.时间);
        }

        // 约定：中心坐标/尺寸 为 Vector3D；轮廓编码为 vector<int64_t>
        return 观测到存在(
            场景,
            观测.中心坐标,
            观测.尺寸,
            观测.轮廓编码,
            p,
            now);
    }
};


